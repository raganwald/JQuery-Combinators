{"name":"jQuery Combinators","tagline":"The jQuery plugin with the cerebral name and the practical methods","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"About jQuery Combinators\r\n===\r\n\r\njQuery Combinators adds five very useful methods to every jQuery selection: `tap`, `into`, `select`, `ergo` and `when`. These allow you to use your own functions as if they were built-in jQuery methods, which makes your code cleaner and more \"jQuery-like.\"\r\n\r\ntl;dr\r\n---\r\n\r\nAll five methods are documented in full, but here's a cheat sheet. Given that `$(...)` is a jQuery selection of some kind, and given that `fn` is a function taking a jQuery selection as an argument:\r\n\r\n**tap** executes the function for side effects, then returns the original selection. This is useful for making your own jQuery methods that \"chain\" fluently:\r\n    \r\n    $(...).tap(fn) =>\r\n      fn($(...));\r\n      return $(...);\r\n\r\n**into** returns the result of the function. This is useful for making your own jQuery traverses or inspectors that act like `.size()` and `.attr`:\r\n    \r\n    $(...).into(fn) =>\r\n      return fn($(...));\r\n\r\n**select** returns the result of the function, just like `.into`, however it preserves the atomicity of filters. This is useful for making complex filter functions, because they work as expected when you use `.end()`:\r\n    \r\n    $(...).select(fn) =>\r\n      return fn($(...));\r\n    \r\n**ergo** always return the selection. It will execute the function if the selection is not empty. This is useful for eliminating selection checks in methods:\r\n    \r\n    $(...).ergo(fn) =>\r\n      if ($(...).length)\r\n        fn($(...));\r\n      return $(...)\r\n    \r\n**when** executes the function, and returns the original selection if the function returned truthy, otherwise it returns an empty selection. This is useful for refactoring if statements into chaining jQuery methods:\r\n    \r\n    $(...).when(fn) =>\r\n      if (fn($(...)))\r\n        return $(...).filter('*');\r\n      else\r\n        return $(...).filter(':not(*)');\r\n\r\nExample code\r\n---\r\n\r\nHere's the [fully annotated source code][life] for an implementation of Conway's Game of Life.\r\n\r\n[life]: ./life/life.html\r\n\r\ntap\r\n---\r\n\r\nIt's common to want to perform a series of operations on a selection. jQuery has many built-in methods that always return their receiver to facilitate this kind of programming. You can make your own methods that return the selection with `.tap`: It turns any function into a jQuery style \"fluent\" function that returns its argument. For example:\r\n\r\n    $('...')\r\n      .tap(function (bar) {\r\n        ...\r\n        return 'blitz';\r\n      })\r\n  \r\n    // => passes $('...') to the function and always returns $('...') and not 'blitz'.\r\n  \r\nHere's a real example from [a Go program][go]. The sample code calculates how many white and black stones have been captured, then uses `.tap` to call a function that updates a display element:\r\n\r\n    var increment_captured_display = function (captured_stones, colour) {\r\n      // ...\r\n    };\r\n\r\n    board\r\n    \t.find($.map(this_move['K'].split(','), '\"#\" + _'.lambda()).join(','))\r\n    \t\t.filter('.white')\r\n    \t\t\t.tap(increment_captured_display, 'white')\r\n    \t\t\t.removeClass('white')\r\n    \t\t\t.addClass('changed was_white')\r\n    \t\t\t.end()\r\n    \t\t.filter('.black')\r\n    \t\t\t.tap(increment_captured_display, 'black')\r\n    \t\t\t.removeClass('black')\r\n    \t\t\t.addClass('changed was_black')\r\n    \t\t\t.end();\r\n  \t\t\t\r\nWe could have used `.into` to make this code clean, but then we'd have to fiddle around with our functions to make sure they return their receiver. With `.tap`, we are sure that we will get \"self\" back whether the function returns something else or even nothing at all.\r\n\r\nAlso, did you notice that we passed the function and another parameter to `.tap`? With all of jQuery Combinators, extra parameters will be passed to the function along with the selection. Functional programmers will tell you that this isn't strictly necessary, however `.curry` isn't to everybody's taste. \r\n      \r\n\r\ninto\r\n---\r\n\r\n`into` is a method that works with any jQuery object. You pass a function to `.into`, and `into` passes its\r\nreceiver to the function and returns whatever the function returns. In other words, `into` turns any function\r\n(including an anonymous function) into your own jQuery method. `into` also handy in OO languages like Ruby when you want to make chains of function calls into a chain of methods. Since jQuery's style is to prefer chains of methods, `into` is a natural fit with jQuery.\r\n\r\nFor example, you might have a function that turns a jQuery selection into a selector string that selects the elements by id:\r\n\r\n    var selectors = function (selection) {\r\n      return $.map(selection, function (el) {\r\n       return '#' + el.id;\r\n      }).join(',');\r\n    };\r\n    \r\nWith `into`, you can use that anywhere you like in jQuery style:\r\n\r\n    $(...)\r\n      .into(selectors) // returns a selector string\r\n\r\nNow your function works just like one of jQuery's built-in methods. You can do this with any function that takes a jQuery object as its parameter, even an anonymous function. `into` is especially useful with functions that transform one selection into another. This is equivalent to adding your own DOM traverses to jQuery. jQuery's built-in traverses like `closest` or `siblings` are all general-purpose. But your specific web application will probably need its own domain-specific traverses.\r\n\r\nIn the game [Go][go], it is very common to want to find the intersections that are adjacent to some set of intersections on the board. The intersections are arranged in rows, so while `previous` and `next` an find adjacent intersections in the same row, you need something else to find the intersections above and below an intersection. Furthermore, Go's rules often require working with the intersections that are adjacent to a group of intersections on the board.\r\n\r\nWithout boring you with the exact code, let's assume you write a function to find the intersections adjacent to a selection of intersections:\r\n\r\n    var adjacent = function (selection_of_intersections) {\r\n    \t...\r\n    \treturn adjacent_intersections;\r\n    };\r\n\r\nNow you can use `adjacent` just like any other jQuery traversal:\r\n\r\n    $(...)\r\n      .into(adjacent) // returns a selection of adjacent intersections\r\n\r\nIn summary, `.into` lets you write your own jQuery methods on the fly without having to inject them into the global namespace as your own plugin. This encourages you to write your code in \"jQuery style.\"\r\n\r\nselect\r\n---\r\n\r\njQuery's built-in selection filters do clever things with a stack so that you can always call `.end()` to restore the previous selection. `into` does no such thing, although any `.find` or `.filter` you call inside of `.into` will work with jQuery's built-in stack. For creating your own filters, jQuery Combinators provides `.select`. It always preserves the previous state of the filter stack.\r\n\r\nIn Go, it's common to want to find the empty intersections within a selection. This code is short enough to repeat here:\r\n\r\n\t\tvar empties = function (intersections) {\r\n\t\t\treturn intersections\r\n\t\t\t\t.filter('.intersection:not(.black):not(.white)');\r\n\t\t};\r\n\t\t\r\nYou can use `empties` just like a jQuery filter:\r\n\r\n    $(...)\r\n      .select(empties) // returns a selection of empty intersections\r\n      \r\nOr combine a traverse with a filter to find the number of liberties (empty adjacent intersections):\r\n\r\n    $(...)\r\n      .into(adjacent)\r\n        .select(empties)\r\n\r\nergo\r\n---\r\n\r\nRuby programmers are familiar with [andand][andand] and the closely related [try][try]. These allow for conditional method invocation: In Ruby, you sometimes want to invoke a method provided the receiver is not null. This is important, because most methods raise an exception when invoked on a null object. If you use `.andand` or `.try`, you can send a method to an object and nothing happens if it's null.\r\n\r\njQuery's built-in methods already work like this. If you have an empty selection, you can invoke all kinds of jQuery methods on it, and nothing happens if your selection is empty. For example, `$('.aBcXyZ').addClass('fubar')` does absolutely nothing if you don't have any elements of class `aBcXyZ`. That's great, and it keeps jQuery code clean: You don't have to litter jQuery code with `if (selection.length)` checks everywhere.\r\n\r\nBut what about methods you create with `.tap`? If all they do is call jQuery's built-in methods, they will work just fine. But once in a while, you might write a function containing some code that you don't want executed on an empty selection. For example:\r\n\r\n    var updated_killed_count = function (killed_stones) {\r\n      // ...\r\n      // some code updating a counter on the board\r\n      // ...\r\n      alert(\"Congratulations, you have killed \" + killed_stones + ' stone(s).');\r\n    }\r\n    \r\nThis won't work very well if there are no killed stones:\r\n\r\n![Congratulations](http://github.com/raganwald/JQuery-Combinators/raw/master/congratulations.png)\r\n\r\nWith `tap`, you would have to wrap your function call in a conditional to avoid an embarrassment:\r\n\r\n    board\r\n      .find('.killed')\r\n        .tap(function (killed_stones) {\r\n          if (killed_stones.length) updated_killed_count(killed_stones);\r\n        })\r\n        .removeClass('black white');\r\n      \r\nThis comes up so often, jQuery Combinators provides a special form of `tap` called `ergo` that bakes the selection check right in:\r\n\r\n    board\r\n      .find('.killed')\r\n        .ergo(updated_killed_count)\r\n        .removeClass('black white');\r\n\r\nLike `tap`, `ergo` always returns its receiver. The difference is that `ergo` only invokes the function if the selection isn't empty. Getting rid of the conditional makes the code much cleaner, and it saves you from having to add conditional checks to your functions.\r\n\r\nThere's another, more subtle benefit. If you use jQuery Combinator with Oliver Steele's excellent [Functional Javascript][fj], you already can use string lambdas as well as functions. For example, you can write `$(...).T(\".attr('id)\")` instead of `$(...).T(function (el) {  return el.attr('id); })`. The limitation of String Lambdas is that they work with functions that are expressions. You can't write `.tap('if (_.length) alert(\"congratulations, you killed \"+_.length+\" stones\")')`. But you *can* write `.ergo('alert(\"congratulations, you killed \"+_.length+\" stones\")')`. Aha!\r\n\r\nwhen\r\n---\r\n\r\nOnce you start using `into`, it'll only be a matter of time before you look at code like this:\r\n\r\n    var group = board.find(...);\r\n    \r\n    if (group.into(liberties).length == 1)\r\n      group\r\n        .removeClass('dead')\r\n        .addClass('atari');\r\n\r\nAnd wonder whether there's some way to get rid of the clumsy `if` statement so that everything can chain in fluent jQuery style. You could do something by stuffing the `if` inside of a function with `into`, but the cure would be worse than the disease. But \"Do something with a selection when such-and-such an expression is truthy\" is common enough that jQuery Combinators provides a method for this special case called `when`.\r\n\r\n`when` is a special filter that passes your selection to a function. If the function returns truthy, `when` keeps your selection. If the function returns falsy, when reduces the selection to an empty selection. So the code above could be written like this:\r\n\r\n    board\r\n      .find(...)\r\n        .when(function(group) { return group.into(liberties).length == 1; })\r\n          .removeClass('dead')\r\n          .addClass('atari');\r\n\r\n`when` is really handy with string lambdas. For example, here's how to mark the intersection that would \"kill\" a group in atari:\r\n\r\n    board\r\n      .find(...)\r\n        .into(liberties)\r\n          .when('.length == 1')\r\n            .addClass('kills_a_group');\r\n              \r\nThis code finds a group, uses `adjacent` and `empties` to traverse to the adjacent empty intersections, then passes that selection along to add the class `'kills_a_group'` if its length is one. `when` can be combined with `ergo` to replace complex if statements with chains of method calls in jQuery style.\r\n\r\nWhy is this plugin called jQuery \"Combinators?\"\r\n---\r\n\r\n`into` is known in some CS circles as the [Thrush][t] or `T` combinator.  For that reason, you can also write `.T` instead of `.into` with jQuery Combinators. Both `.into` and `.T` work, and both are acceptable. Prefer `into` if you like a conversational program that will be familiar to Ruby programmers. Prefer `T` if you and your team are comfortable with the more brief, academic terminology. Neither is superior to the other. `T` is not a snobbish, intellectually violent choice, and `into` isn't \"instantly readable\" for anyone who has never seen it before.\r\n\r\n`tap` is known in combinatory logic circles as the \"K Combinator\" or [Kestrel][k]. For this reason, you can write `$(...).K(...)` as well as `$(...).tap(...)`. Like `into` and `T`, use what you prefer, they're both correct.\r\n\r\nTo simplify the explanation radically, `T` and `K` are called combinators because they combine things to produce a result in different ways. Functional programmers call such things higher-order functions, but what makes combinators interesting is that combinators work by rearranging the order of things in an expression.\r\n\r\nFor example, `T` reverses the order of two things. Think about it: Instead of writing `adjacent $(...)` we use `T` to write `$(...).T(adjacent)`. That rearrangement is very handy for making our code conform to jQuery style. Likewise, `K` leaves them in the same order but removes something. So if `update(...)` returns some text, `$(...).T(update) => \"some text\"`, but `$(...).K(update) => $(...)`. It's like `update` got dropped out of our expression. This ability to rearrange things is what makes them so useful for taking code that would normally have function calls sprinkled throughout it and rearranging it into a nice tree of method calls in jQuery style.\r\n\r\nMany other combinators exist, and they are all interesting with applications for functional and OO programmers. With combinators you can even get rid of parentheses in a programming language! If you aren't familiar with Combinatory Logic, I encourage you to follow the links to my posts about Kestrels and Thrushes, and better still do a little digging about Combinatory Logic in general. It's a rich, fascinating field of study that is so simple it's incredibly easy to pick up, and it leads naturally into functional and [concatenative][joy] languages.\r\n\r\nCoffeeScript Ristretto\r\n-------------\r\n\r\nIf you like jQuery Combinators, you'll **love** my new book [CoffeeScript Ristretto](http://leanpub.com/coffeescript-ristretto). Check it out!\r\n\t\t\t\t\t\r\n[k]: http://github.com/raganwald/homoiconic/blob/master/2008-10-29/kestrel.markdown#readme\r\n[t]: http://github.com/raganwald/homoiconic/blob/master/2008-10-30/thrush.markdown#readme\r\n[go]: http://raganwald.github.com/go/\r\n[jou]: http://orly.ch/\r\n[tap]: http://github.com/jou/jquery.tap.js\r\n[raganwald]: http://reginald.braythwayt.com\r\n[joy]: http://github.com/raganwald/homoiconic/blob/master/2008-11-16/joy.md\r\n[fj]: http://osteele.com/sources/javascript/functional/ \"Functional Javascript\"\r\n[andand]: http://github.com/raganwald/andand\r\n[try]: http://ozmm.org/posts/try.html"}